// RSFGA OpenFGA-compatible protobuf definitions
// Wire-format compatible with OpenFGA v1 API
syntax = "proto3";

package openfga.v1;

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// ============================================================
// Core Types
// ============================================================

// TupleKey represents a relationship tuple
message TupleKey {
  string user = 1;
  string relation = 2;
  string object = 3;
  RelationshipCondition condition = 4;
}

// TupleKeyWithoutCondition for queries that don't include conditions
message TupleKeyWithoutCondition {
  string user = 1;
  string relation = 2;
  string object = 3;
}

// Tuple with metadata
message Tuple {
  TupleKey key = 1;
  google.protobuf.Timestamp timestamp = 2;
}

// RelationshipCondition for conditional relationships
message RelationshipCondition {
  string name = 1;
  google.protobuf.Struct context = 2;
}

// ContextualTupleKeys for contextual tuples in check requests
message ContextualTupleKeys {
  repeated TupleKey tuple_keys = 1;
}

// ============================================================
// Store Types
// ============================================================

message Store {
  string id = 1;
  string name = 2;
  google.protobuf.Timestamp created_at = 3;
  google.protobuf.Timestamp updated_at = 4;
  google.protobuf.Timestamp deleted_at = 5;
}

// ============================================================
// Authorization Model Types
// ============================================================

message AuthorizationModel {
  string id = 1;
  string schema_version = 2;
  repeated TypeDefinition type_definitions = 3;
  map<string, Condition> conditions = 4;
}

message TypeDefinition {
  string type = 1;
  map<string, Userset> relations = 2;
  Metadata metadata = 3;
}

message Userset {
  oneof userset {
    DirectUserset this = 1;
    ObjectRelation computed_userset = 2;
    TupleToUserset tuple_to_userset = 3;
    Usersets union = 4;
    Usersets intersection = 5;
    Difference difference = 6;
  }
}

message DirectUserset {}

message ObjectRelation {
  string object = 1;
  string relation = 2;
}

message TupleToUserset {
  ObjectRelation tupleset = 1;
  ObjectRelation computed_userset = 2;
}

message Usersets {
  repeated Userset child = 1;
}

message Difference {
  Userset base = 1;
  Userset subtract = 2;
}

message Metadata {
  map<string, RelationMetadata> relations = 1;
  string module = 2;
  string source_info = 3;
}

message RelationMetadata {
  repeated RelationReference directly_related_user_types = 1;
  string module = 2;
  string source_info = 3;
}

message RelationReference {
  string type = 1;
  oneof relation_or_wildcard {
    string relation = 2;
    Wildcard wildcard = 3;
  }
  string condition = 4;
}

message Wildcard {}

message Condition {
  string name = 1;
  string expression = 2;
  map<string, ConditionParamTypeRef> parameters = 3;
  ConditionMetadata metadata = 4;
}

message ConditionParamTypeRef {
  TypeName type_name = 1;
  repeated TypeName generic_types = 2;
}

enum TypeName {
  TYPE_NAME_UNSPECIFIED = 0;
  TYPE_NAME_ANY = 1;
  TYPE_NAME_BOOL = 2;
  TYPE_NAME_STRING = 3;
  TYPE_NAME_INT = 4;
  TYPE_NAME_UINT = 5;
  TYPE_NAME_DOUBLE = 6;
  TYPE_NAME_DURATION = 7;
  TYPE_NAME_TIMESTAMP = 8;
  TYPE_NAME_MAP = 9;
  TYPE_NAME_LIST = 10;
  TYPE_NAME_IPADDRESS = 11;
}

message ConditionMetadata {
  string module = 1;
  string source_info = 2;
}

// ============================================================
// Assertion Types
// ============================================================

message Assertion {
  TupleKey tuple_key = 1;
  bool expectation = 2;
  repeated TupleKey contextual_tuples = 3;
}

message Assertions {
  repeated Assertion assertions = 1;
}
