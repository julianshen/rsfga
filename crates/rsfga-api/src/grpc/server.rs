//! gRPC server setup and transport layer.
//!
//! This module provides the gRPC transport layer using Tonic, including:
//! - Server initialization with the OpenFGA service
//! - gRPC reflection for service discovery (grpcurl support)
//! - Health check service for load balancer integration
//!
//! # Architecture
//!
//! ```text
//! gRPC Client
//!     ↓
//! tonic::transport::Server
//!     ├── OpenFgaServiceServer (main service)
//!     ├── HealthServer (health checks)
//!     └── ReflectionServer (service discovery)
//! ```

use std::net::SocketAddr;
use std::sync::Arc;

use tonic::transport::Server;
use tonic_health::server::health_reporter;
use tracing::info;

use rsfga_storage::DataStore;

use super::{OpenFgaGrpcService, OpenFgaServiceServer};

/// File descriptor set for gRPC reflection.
/// Generated by tonic-build at compile time.
pub const FILE_DESCRIPTOR_SET: &[u8] = tonic::include_file_descriptor_set!("openfga_descriptor");

/// Configuration for the gRPC server.
#[derive(Debug, Clone)]
pub struct GrpcServerConfig {
    /// Enable gRPC reflection for service discovery
    pub reflection_enabled: bool,

    /// Enable health check service
    pub health_check_enabled: bool,
}

impl Default for GrpcServerConfig {
    fn default() -> Self {
        Self {
            reflection_enabled: true,
            health_check_enabled: true,
        }
    }
}

/// Run the gRPC server.
///
/// This starts a Tonic gRPC server with the OpenFGA service implementation,
/// optionally including reflection and health check services.
///
/// # Arguments
///
/// * `storage` - The storage backend to use
/// * `addr` - The address to bind to
/// * `config` - Server configuration options
///
/// # Returns
///
/// Returns when the server is shut down or encounters an error.
pub async fn run_grpc_server<S>(
    storage: Arc<S>,
    addr: SocketAddr,
    config: GrpcServerConfig,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
where
    S: DataStore + Send + Sync + 'static,
{
    info!(%addr, "Starting gRPC server");

    // Create the OpenFGA service
    let openfga_service = OpenFgaGrpcService::new(storage);
    let openfga_server = OpenFgaServiceServer::new(openfga_service);

    // Build the server
    let mut builder = Server::builder();

    // Add health check service if enabled
    let (mut health_reporter, health_service) = health_reporter();
    if config.health_check_enabled {
        // Set the OpenFGA service as serving
        health_reporter
            .set_serving::<OpenFgaServiceServer<OpenFgaGrpcService<S>>>()
            .await;
        info!("gRPC health check service enabled");
    }

    // Add reflection service if enabled
    if config.reflection_enabled {
        let reflection_service = tonic_reflection::server::Builder::configure()
            .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
            .build()?;

        info!("gRPC reflection service enabled");

        if config.health_check_enabled {
            builder
                .add_service(openfga_server)
                .add_service(health_service)
                .add_service(reflection_service)
                .serve(addr)
                .await?;
        } else {
            builder
                .add_service(openfga_server)
                .add_service(reflection_service)
                .serve(addr)
                .await?;
        }
    } else if config.health_check_enabled {
        builder
            .add_service(openfga_server)
            .add_service(health_service)
            .serve(addr)
            .await?;
    } else {
        builder.add_service(openfga_server).serve(addr).await?;
    }

    info!("gRPC server shutdown complete");
    Ok(())
}

/// Run the gRPC server with graceful shutdown.
///
/// This wraps `run_grpc_server` with a shutdown signal handler.
pub async fn run_grpc_server_with_shutdown<S>(
    storage: Arc<S>,
    addr: SocketAddr,
    config: GrpcServerConfig,
    shutdown_signal: impl std::future::Future<Output = ()> + Send + 'static,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
where
    S: DataStore + Send + Sync + 'static,
{
    info!(%addr, "Starting gRPC server with graceful shutdown");

    // Create the OpenFGA service
    let openfga_service = OpenFgaGrpcService::new(storage);
    let openfga_server = OpenFgaServiceServer::new(openfga_service);

    // Build the server
    let mut builder = Server::builder();

    // Add health check service if enabled
    let (mut health_reporter, health_service) = health_reporter();
    if config.health_check_enabled {
        health_reporter
            .set_serving::<OpenFgaServiceServer<OpenFgaGrpcService<S>>>()
            .await;
        info!("gRPC health check service enabled");
    }

    // Add reflection service if enabled
    if config.reflection_enabled {
        let reflection_service = tonic_reflection::server::Builder::configure()
            .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
            .build()?;

        info!("gRPC reflection service enabled");

        if config.health_check_enabled {
            builder
                .add_service(openfga_server)
                .add_service(health_service)
                .add_service(reflection_service)
                .serve_with_shutdown(addr, shutdown_signal)
                .await?;
        } else {
            builder
                .add_service(openfga_server)
                .add_service(reflection_service)
                .serve_with_shutdown(addr, shutdown_signal)
                .await?;
        }
    } else if config.health_check_enabled {
        builder
            .add_service(openfga_server)
            .add_service(health_service)
            .serve_with_shutdown(addr, shutdown_signal)
            .await?;
    } else {
        builder
            .add_service(openfga_server)
            .serve_with_shutdown(addr, shutdown_signal)
            .await?;
    }

    info!("gRPC server shutdown complete");
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[allow(clippy::const_is_empty)]
    fn test_file_descriptor_set_is_valid() {
        // The file descriptor set should be non-empty
        assert!(!FILE_DESCRIPTOR_SET.is_empty());
        // It should be a valid protobuf file descriptor set
        // (the reflection service will parse it, so if it's invalid, the server won't start)
    }

    #[test]
    fn test_grpc_server_config_default() {
        let config = GrpcServerConfig::default();
        assert!(config.reflection_enabled);
        assert!(config.health_check_enabled);
    }
}
