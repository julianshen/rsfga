//! gRPC server setup and transport layer.
//!
//! This module provides the gRPC transport layer using Tonic, including:
//! - Server initialization with the OpenFGA service
//! - gRPC reflection for service discovery (grpcurl support)
//! - Health check service for load balancer integration
//!
//! # Architecture
//!
//! ```text
//! gRPC Client
//!     ↓
//! tonic::transport::Server
//!     ├── OpenFgaServiceServer (main service)
//!     ├── HealthServer (health checks)
//!     └── ReflectionServer (service discovery)
//! ```

use std::net::SocketAddr;
use std::sync::Arc;

use tonic::transport::server::Router;
use tonic::transport::Server;
use tonic_health::server::{health_reporter, HealthReporter};
use tonic_health::ServingStatus;
use tracing::info;

use rsfga_storage::DataStore;

use super::{OpenFgaGrpcService, OpenFgaServiceServer};

/// File descriptor set for gRPC reflection.
/// Generated by tonic-build at compile time.
pub const FILE_DESCRIPTOR_SET: &[u8] = tonic::include_file_descriptor_set!("openfga_descriptor");

/// Configuration for the gRPC server.
#[derive(Debug, Clone)]
pub struct GrpcServerConfig {
    /// Enable gRPC reflection for service discovery
    pub reflection_enabled: bool,

    /// Enable health check service
    pub health_check_enabled: bool,
}

impl Default for GrpcServerConfig {
    fn default() -> Self {
        Self {
            reflection_enabled: true,
            health_check_enabled: true,
        }
    }
}

/// Result from building the gRPC router, including optional health reporter for lifecycle management.
struct GrpcRouterResult {
    router: Router,
    /// Health reporter for updating service status during graceful shutdown.
    /// Only present when health_check_enabled is true.
    health_reporter: Option<HealthReporter>,
}

/// Build the gRPC server router with configured services.
///
/// This helper function configures all gRPC services based on the provided config,
/// reducing duplication between `run_grpc_server` and `run_grpc_server_with_shutdown`.
///
/// Returns the router and an optional health reporter for lifecycle management.
async fn build_grpc_router<S>(
    storage: Arc<S>,
    config: &GrpcServerConfig,
) -> Result<GrpcRouterResult, Box<dyn std::error::Error + Send + Sync>>
where
    S: DataStore + Send + Sync + 'static,
{
    // Create the OpenFGA service
    let openfga_service = OpenFgaGrpcService::new(storage);
    let openfga_server = OpenFgaServiceServer::new(openfga_service);

    // Start with base server and add the main service
    let mut router = Server::builder().add_service(openfga_server);
    let mut health_reporter_opt = None;

    // Add health check service if enabled
    if config.health_check_enabled {
        let (mut health_reporter, health_service) = health_reporter();
        health_reporter
            .set_serving::<OpenFgaServiceServer<OpenFgaGrpcService<S>>>()
            .await;
        info!("gRPC health check service enabled");
        router = router.add_service(health_service);
        health_reporter_opt = Some(health_reporter);
    }

    // Add reflection service if enabled
    if config.reflection_enabled {
        let reflection_service = tonic_reflection::server::Builder::configure()
            .register_encoded_file_descriptor_set(FILE_DESCRIPTOR_SET)
            .build()?;
        info!("gRPC reflection service enabled");
        router = router.add_service(reflection_service);
    }

    Ok(GrpcRouterResult {
        router,
        health_reporter: health_reporter_opt,
    })
}

/// Run the gRPC server.
///
/// This starts a Tonic gRPC server with the OpenFGA service implementation,
/// optionally including reflection and health check services.
///
/// # Arguments
///
/// * `storage` - The storage backend to use
/// * `addr` - The address to bind to
/// * `config` - Server configuration options
///
/// # Returns
///
/// Returns when the server is shut down or encounters an error.
pub async fn run_grpc_server<S>(
    storage: Arc<S>,
    addr: SocketAddr,
    config: GrpcServerConfig,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
where
    S: DataStore + Send + Sync + 'static,
{
    info!(%addr, "Starting gRPC server");

    let GrpcRouterResult {
        router,
        health_reporter,
    } = build_grpc_router(storage, &config).await?;
    // Keep health_reporter alive for the lifetime of the server
    let _health_reporter = health_reporter;
    router.serve(addr).await?;

    info!("gRPC server shutdown complete");
    Ok(())
}

/// Run the gRPC server with graceful shutdown.
///
/// Similar to `run_grpc_server`, but accepts a shutdown signal for graceful termination.
/// When the shutdown signal completes, the server will:
/// 1. Update health status to NOT_SERVING (allows load balancers to drain connections)
/// 2. Stop accepting new connections
/// 3. Wait for existing requests to complete before returning
pub async fn run_grpc_server_with_shutdown<S>(
    storage: Arc<S>,
    addr: SocketAddr,
    config: GrpcServerConfig,
    shutdown_signal: impl std::future::Future<Output = ()> + Send + 'static,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
where
    S: DataStore + Send + Sync + 'static,
{
    info!(%addr, "Starting gRPC server with graceful shutdown");

    let GrpcRouterResult {
        router,
        health_reporter,
    } = build_grpc_router(storage, &config).await?;

    // Wrap the shutdown signal to update health status before stopping
    let graceful_shutdown = async move {
        shutdown_signal.await;

        // Update health status to NOT_SERVING before shutdown
        // This allows load balancers to stop sending new requests
        if let Some(mut reporter) = health_reporter {
            info!("Setting health status to NOT_SERVING for graceful shutdown");
            reporter
                .set_service_status("openfga.v1.OpenFgaService", ServingStatus::NotServing)
                .await;
        }
    };

    router.serve_with_shutdown(addr, graceful_shutdown).await?;

    info!("gRPC server shutdown complete");
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[allow(clippy::const_is_empty)]
    fn test_file_descriptor_set_is_valid() {
        // The file descriptor set should be non-empty
        assert!(!FILE_DESCRIPTOR_SET.is_empty());
        // It should be a valid protobuf file descriptor set
        // (the reflection service will parse it, so if it's invalid, the server won't start)
    }

    #[test]
    fn test_grpc_server_config_default() {
        let config = GrpcServerConfig::default();
        assert!(config.reflection_enabled);
        assert!(config.health_check_enabled);
    }
}
